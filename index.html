<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Sequence Observer - Reconnaissance</title>
    <style>
        body { font-family: sans-serif; background: #f4f7f6; padding: 20px; color: #333; }
        #root { max-width: 800px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .recon-log { background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 4px; font-family: monospace; margin-top: 20px; font-size: 0.9em; }
        .recon-log h4 { color: #569cd6; margin-top: 0; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .event-line { margin: 5px 0; border-left: 2px solid #4ec9b0; padding-left: 10px; }
        .event-name { color: #ce9178; font-weight: bold; }
        .control-panel { display: flex; gap: 10px; margin-bottom: 20px; }
        input { flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        button { padding: 8px 16px; background: #2563eb; color: #fff; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #1d4ed8; }
        ul { list-style: none; padding: 0; }
        li { padding: 8px; border-bottom: 1px solid #eee; }
    </style>
</head>
<body>
    <div id="root">
        </div>

    <script>
        // 정찰 지침: 모든 통신 행위는 기술적 식별자를 통해 추적 가능해야 함
        const Store = {
            tasks: [],
            traces: [] 
        };

        const App = {
            // 1. 서버 통신 및 정찰 데이터 동기화
            async request(path, method = 'GET', body = null) {
                try {
                    const res = await fetch(path, {
                        method,
                        headers: body ? { 'Content-Type': 'application/json' } : {},
                        body: body ? JSON.stringify(body) : null
                    });

                    // 서버의 관측 헤더 확보
                    const traceHeader = res.headers.get('X-Sequence-Trace');
                    if (traceHeader) {
                        Store.traces = JSON.parse(traceHeader);
                    }

                    // 상태 규격을 기록
                    if (!res.ok) {
                        this.logInternalState("HTTP_STATUS_EXCEPTION", { 
                            status: res.status, 
                            method: method, 
                            path: path 
                        });
                        return { err: `HTTP_${res.status}` };
                    }

                    return await res.json();
                    
                } catch (e) {
                    // 네트워크 단절 등 물리적 계층의 오류 기록
                    this.logInternalState("TRANSPORT_LAYER_ERROR", { 
                        type: e.name, 
                        message: e.message 
                    });
                    return { err: "CONNECTION_REFUSED" };
                }
            },

            // 2. 관측 데이터 규격화 및 렌더링 트리거
            logInternalState(event, data) {
                Store.traces.push({
                    event: `SIGNAL_${event}`,
                    data: data
                });
                this.render();
            },

            // 3. 비즈니스 로직 (CRUD)
            async loadTasks() {
                const data = await this.request('/api/tasks');
                if (!data.err) {
                    Store.tasks = data.tasks || [];
                }
                this.render();
            },

            async addTask() {
                const input = document.getElementById('taskInput');
                if (!input.value) return;

                const result = await this.request('/api/tasks', 'POST', { task: input.value });
                if (!result.err) {
                    input.value = '';
                    await this.loadTasks();
                }
            },

            // 4. 관측 가시성을 극대화한 렌더링
            render() {
                const root = document.getElementById('root');
                if (!root) return;
                
                root.innerHTML = `
                    <h3>CRUD & Sequence Observation</h3>
                    
                    <div class="control-panel">
                        <input type="text" id="taskInput" placeholder="기록할 과업 명칭...">
                        <button onclick="App.addTask()">과업 확정</button>
                    </div>

                    <div class="content-view">
                        <h4>Storage List</h4>
                        <ul>
                            ${Store.tasks.length > 0 
                                ? Store.tasks.map(t => `<li>${t}</li>`).join('') 
                                : '<li>비어 있는 저장소입니다.</li>'}
                        </ul>
                    </div>

                    <div class="recon-log">
                        <h4>Reconnaissance: Sequence Trace</h4>
                        <div class="trace-box" style="background: #121212; border: 1px solid #333; padding: 12px;">
                            ${Store.traces.map(t => `
                                <div class="event-line" style="border-bottom: 1px solid #222; padding: 4px 0;">
                                    <span class="event-tag" style="color: #dcdcaa; font-weight: bold;">[${t.event}]</span> 
                                    <span class="event-payload" style="color: #9cdcfe; font-size: 0.9em;">${JSON.stringify(t.data)}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
        };

        window.onload = () => App.loadTasks();
    </script>

</body>
</html>